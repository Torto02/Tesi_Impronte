#include <iostream>
#include <string.h>
#include <stdlib.h>

#include "../include/files.h"
#include "../include/fingerprint.h"

void print_usage(char* prog_name)
{
	std::cout << "USAGE:" << std::endl;
	std::cout << prog_name << " @input_folder [options]" << std::endl << std::endl;
	std::cout << "OPTIONS:" << std::endl;

	std::cout << "-o @output_folder" << std::endl;
	std::cout << "	Set the path for the output_files." << std::endl;
	std::cout << "	Otherwise the path is the same as @input_file + '/inheritance'." << std::endl;

	std::cout << "-sourceAFIS" << std::endl;
	std::cout << "	Uses the structure of the folder generated by sourceAFIS." << std::endl;
	std::cout << "	(If this is used the following I/O commands are ignored)." << std::endl;

	std::cout << "-boundingBox" << std::endl;
	std::cout << "	Test to experiment on the Bounding Box." << std::endl;

	std::cout << "-java_BB" << std::endl;
	std::cout << "	Test to experiment on the Bounding Box." << std::endl;

	std::cout << "-fp_name" << std::endl;
	std::cout << "	Used to name the fingerprint (for ASP facts)." << std::endl;

	std::cout << "-erosion" << std::endl;
	std::cout << "	Used to set the number of pixel to erode from the fingerprint (Default: 10)." << std::endl;

	std::cout << "-AFIS_edges" << std::endl;
	std::cout << "	To print out the edges generated by sourceAFIS." << std::endl;

	std::cout << "-minutiae @minutiae_file" << std::endl;
	std::cout << "	The name of the file that contains the minutiae description in Json." << std::endl;

	std::cout << "-skeleton @skeleton_files" << std::endl;
	std::cout << "	The prefix of the files (no extenstion) that contain the " << std::endl;
	std::cout << "	skeleton description in '.json' and the skeleton information in '.dat'." << std::endl;
	exit(1);
}

int main(int argc, char** argv)
{
	bool output_folder_set = false;
	bool minutiae_file_set = false;
	bool skeleton_files_set = false;
	bool boundingBox = false;
	bool java_BB = false;
	bool afis_edges = false;

	bool sourceAFIS = false;
	if (argc < 2)
		print_usage(argv[0]);

	int i = 2;
	while (i < argc) {
		if (strcmp(argv[i], "-sourceAFIS") == 0) {
			sourceAFIS = true;
		} else if (strcmp(argv[i], "-boundingBox") == 0) {
			boundingBox = true;
		} else if (strcmp(argv[i], "-fp_name") == 0) {
			i++;
			if (i <= argc) {
				files::get_instance().set_fp_name(argv[i]);
			} else {
				std::cerr << "\n -fp_name needs an argument\n";
				print_usage(argv[0]);
			}
		} else if (strcmp(argv[i], "-java_BB") == 0) {
			java_BB = true;
			boundingBox = true;
		} else if (strcmp(argv[i], "-AFIS_edges") == 0) {
			afis_edges = true;
		} else if (strcmp(argv[i], "-erosion") == 0) {
			i++;
			if (i <= argc) {
				files::get_instance().set_erosion_time(std::stoi(argv[i]));
			} else {
				std::cerr << "\n -erosion needs an argument\n";
				print_usage(argv[0]);
			}
		} else if (strcmp(argv[i], "-o") == 0) {
			i++;
			if (i <= argc) {
				std::cerr << "-o needs the name of the output folder." << std::endl;
				exit(1);
			} else {
				files::get_instance().set_output_folder(argv[i]);
				output_folder_set = true;
			}
		} else if (strcmp(argv[i], "-minutiae") == 0) {
			i++;
			if (i >= argc) {
				std::cerr << "-minutiae needs the name of the minutiae file." << std::endl;
				exit(1);
			} else {
				files::get_instance().set_minutiae_file(argv[i]);
				minutiae_file_set = true;
			}
		} else if (strcmp(argv[i], "-skeleton") == 0) {
			i++;
			if (i >= argc) {
				std::cerr << "-skeleton needs the name (without extension) of the skeleton files." << std::endl;
				exit(1);
			} else {
				std::string skeleton_tmp = argv[i];
				files::get_instance().set_skeleton_description(skeleton_tmp + ".json");
				files::get_instance().set_skeleton_data(skeleton_tmp + ".dat");
				skeleton_files_set = true;
			}
		} else {
			print_usage(argv[0]);
		}
		i++;
	}
	files::get_instance().set_input_folder(argv[1]);

	if (sourceAFIS) {

		if (boundingBox) {
			files::get_instance().set_minutiae_file(files::get_instance().get_input_folder() + "/inheritance/edge_minutiae.json");
			if (!java_BB) {
				files::get_instance().set_minutiae_internalBB_file(files::get_instance().get_input_folder() + "/076-shuffled-minutiae.json");
			} else {
				files::get_instance().set_minutiae_internalBB_file(files::get_instance().get_input_folder() + "/inheritance/internal_minutiae.json");
			}
		} else {
			files::get_instance().set_minutiae_file(files::get_instance().get_input_folder() + "/076-shuffled-minutiae.json");
		}
		files::get_instance().set_skeleton_description(files::get_instance().get_input_folder() + "/058-valleys-thinned-skeleton.json");
		if (!java_BB) {
			files::get_instance().set_skeleton_data(files::get_instance().get_input_folder() + "/059-valleys-thinned-skeleton.dat");
		} else {
			files::get_instance().set_skeleton_data(files::get_instance().get_input_folder() + "/inheritance/059B-valleys-thinned-skeleton-bounded.txt");
		}
		files::get_instance().set_output_folder(files::get_instance().get_input_folder() + "/inheritance");
		output_folder_set = true;
		minutiae_file_set = true;
		skeleton_files_set = true;
	}

	if (output_folder_set && minutiae_file_set && skeleton_files_set) {

		system(("mkdir -p " + files::get_instance().get_output_folder()).c_str());


		fingerprint fp(boundingBox);

		//fp.generate_edges_skeleton_ridges(50, 300);
		if (afis_edges) {
			fp.read_afis_edges();
		} else {
			fp.generate_edges_skeleton_ridges_DFS(java_BB);
		}

		//nuove funzionalita'
		//fp.clockwise_sort_minutiae();
		//fp.clockwise_sort_minutiae_easy();

		/*
		 * fp.boundingbox();
		 * fp.create_minutiae_on_bounding_box();
		 * bounding_box.connect();
		 */

		fp.print_json_edges(boundingBox);

		if (!boundingBox) {
			fp.print_json_minutiae();
		}

		fp.generate_edges_distance();
		fp.print_asp();
		fp.generate_triangulation();

		//fp_edges_score_generator score_gen;
		//fp_edges_percentage_generator percentage_gen;
		//fp_edges_percentage_generator_plp plp_gen;

		//score_gen.generate_follow_minutiae_sequentially(0);
		//score_gen.generate_follow_minutiae_file_order();
		//percentage_gen.generate();
		//plp_gen.generate_plp();

		//fp_edges_table::get_instance().incoming_minutia_follow_ridges(50, 300);

	} else {
		print_usage(argv[0]);
	}



	std::cout << "\nThe End:)\n";

	return 0;
}
